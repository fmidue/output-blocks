-- | Defines a monad context for caching.

module Capabilities.Cache (
  MonadCache (..),
  cache,
  cacheT,
  short,
  ) where

import qualified Data.ByteString.Lazy             as LBS (fromStrict)
import qualified Data.ByteString.UTF8             as BS (fromString)

import Control.Monad                    (when)
import Control.Monad.Trans.Class        (MonadTrans (lift))
import Control.Monad.Trans.Maybe        (MaybeT (MaybeT, runMaybeT))
import Control.OutputCapable.Blocks.Generic (GenericReportT)
import Data.ByteString                  (ByteString)
import Data.Digest.Pure.SHA             (sha256, showDigest)
import Data.Maybe                       (fromJust)

class Monad m => MonadCache m where
  appendCollisionFile :: FilePath -> String -> m ()
  doesCacheExist :: FilePath -> m Bool
  readShowFile :: FilePath -> m ByteString
  writeShowFile :: FilePath -> ByteString -> m ()

instance MonadCache m => MonadCache (GenericReportT l o m)  where
  appendCollisionFile f = lift . appendCollisionFile f
  doesCacheExist = lift . doesCacheExist
  readShowFile = lift . readShowFile
  writeShowFile f = lift . writeShowFile f

{-|
Caches some file which is generated by using some 'Show'able input.
The textual representation (using 'show') of the input is stored in a file
next to the generated output.
The provided file path is extended by the provided name, a hash of the textual
representation of the input, and the extension.
-}
cache
  :: (MonadCache m, Show a)
  => FilePath
  -- ^ base file path (prefix of file name)
  -> String
  -- ^ path suffix (including dot and extension)
  -> String
  -- ^ some identifying name for what (part of file name)
  -> a
  -- ^ what
  -> (FilePath -> a -> m b)
  -- ^ how to create something from what
  -> m FilePath
cache path ext name what how = fmap fromJust $ runMaybeT $
  cacheT path ext name what $ \file x -> MaybeT . fmap Just $ how file x

{-|
Caches some file which is generated by using some 'Show'able input.
The textual representation (using 'show') of the input is stored in a file
next to the generated output.
The provided file path is extended by the provided name, a hash of the textual
representation of the input, and the extension.

This function provides caching capabilities when a 'MonadTrans'former is being
used. If such wrapping is not required use 'cache'.
-}
cacheT
  :: (Monad (t m), MonadTrans t, MonadCache m, Show a)
  => FilePath
  -- ^ base file path (prefix of file name)
  -> String
  -- ^ path suffix (including dot and extension)
  -> String
  -- ^ some identifying name for what (part of file name)
  -> a
  -- ^ what
  -> (FilePath -> a -> t m b)
  -- ^ how to create something from what
  -> t m FilePath
cacheT path ext name what how = (file <$) . cacheBy $ how file what
  where
    cacheBy create = do
      let create' = create >> lift (writeShowFile whatFile what')
      isFile <- lift $ doesCacheExist file
      if isFile
        then do
          f <- lift $ readShowFile whatFile
          when (f /= what') $ do
            lift $ appendCollisionFile (path ++ "busted.txt") whatId
            create'
        else create'
    what' = BS.fromString $ show what
    whatId = path ++ name ++ showDigest (sha256 $ LBS.fromStrict what')
    whatFile = whatId ++ ".hs"
    file = whatId ++ ext

short :: Enum a => a -> String
short x = show $ fromEnum x
